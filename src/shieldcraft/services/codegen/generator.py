import pathlib
from .template_engine import TemplateEngine
from .file_plan import FilePlan


class CodeGenerator:
    def __init__(self, template_dir="src/shieldcraft/services/codegen/templates"):
        self.template_dir = pathlib.Path(template_dir)
        self.engine = TemplateEngine(template_dir)
        self.plan_builder = FilePlan()
    
    def _inject_lineage_header(self, content, item):
        """Inject lineage provenance header into generated file."""
        lineage_id = item.get("lineage_id", "unknown")
        spec_ptr = item.get("source_pointer", item.get("ptr", "unknown"))
        source_node_type = item.get("source_node_type", "unknown")
        
        header = f"""# Generated by ShieldCraft Engine
# Lineage ID: {lineage_id}
# Source Pointer: {spec_ptr}
# Source Node Type: {source_node_type}
#
"""
        return header + content

    def run(self, checklist, dry_run=False):
        import hashlib
        file_plan = self.plan_builder.build_file_plan(checklist)
        outputs = []
        content_hashes = []
        
        for entry in file_plan:
            # Check for module type
            source_item = entry.get("source", {})
            item_type = source_item.get("type", "")
            item_category = source_item.get("category", "")
            
            # Bootstrap module generation
            if item_category == "bootstrap":
                # Use bootstrap module template
                template_path = self.template_dir / "bootstrap" / "module_bootstrap.j2"
                
                if template_path.exists():
                    # Read template and render with Jinja2
                    template_content = template_path.read_text()
                    
                    context = {
                        "name": source_item.get("name", source_item.get("ptr", "Unknown").split("/")[-1]),
                        "checklist_id": entry["id"]
                    }
                    
                    # Use Jinja2 directly for proper rendering
                    from jinja2 import Template
                    jinja_template = Template(template_content)
                    rendered = jinja_template.render(context)
                    
                    # Bootstrap output path
                    module_name = context["name"]
                    bootstrap_path = f".selfhost_outputs/bootstrap/{module_name}.py"
                    
                    outputs.append({
                        "path": bootstrap_path,
                        "content": rendered
                    })
                    continue
            
            if item_type == "module":
                # Module generation
                template_path = self.template_dir / "module.j2"
                if not template_path.exists():
                    # Fallback to basic template
                    template_path = self.template_dir / (entry["template_name"] + ".txt")
                
                template = template_path.read_text()
                
                context = {
                    "name": source_item.get("name", "UnknownModule"),
                    "dependencies": source_item.get("dependencies", []),
                    "invariants": source_item.get("invariants", []),
                    "checklist_id": entry["id"]
                }
                
                rendered = self.engine.render(template, context)
                
                # Inject lineage header
                rendered = self._inject_lineage_header(rendered, source_item)
                
                # Module output path
                module_name = source_item.get("name", "unknown")
                module_path = f"src/generated/modules/{module_name}.py"
                
                outputs.append({
                    "path": module_path,
                    "content": rendered
                })
                
                # Compute content hash for dry-run and bundle hash
                content_hash = hashlib.sha256(rendered.encode()).hexdigest()
                content_hashes.append((module_path, content_hash))
                continue
            
            # Route derived task types to templates
            template_map = {
                "module": "module.j2",
                "fix-dependency": "fix_invariant.j2",
                "resolve-cycle": "resolve_cycle.j2",
                "integration": "integration.j2"
            }
            
            template_name = template_map.get(item_type, "module.j2")
            template_path = self.template_dir / template_name
            
            if template_path.exists():
                template_content = template_path.read_text()
                
                # Build context for template
                context = {
                    "lineage_id": source_item.get("lineage_id", "unknown"),
                    "spec_ptr": source_item.get("source_pointer", source_item.get("ptr", "unknown")),
                    "name": source_item.get("name", "unknown"),
                    "invariant_id": source_item.get("invariant_id", ""),
                    "constraint": source_item.get("invariant_constraint", ""),
                    "cycle_items": source_item.get("cycle_items", []),
                    "component_name": source_item.get("name", "component")
                }
                
                from jinja2 import Template
                jinja_template = Template(template_content)
                rendered = jinja_template.render(context)
                
                # Route to output path based on type
                output_map = {
                    "module": f"src/generated/modules/{context['name']}.py",
                    "fix-dependency": f"src/generated/fixes/{source_item.get('id', 'fix')}.py",
                    "resolve-cycle": f"src/generated/cycles/{source_item.get('id', 'cycle')}.py",
                    "integration": f"src/generated/integration/{source_item.get('id', 'test')}.py"
                }
                
                output_path = output_map.get(item_type, f"src/generated/unknown/{source_item.get('id', 'item')}.py")
                
                outputs.append({
                    "path": output_path,
                    "content": rendered
                })
                
                content_hash = hashlib.sha256(rendered.encode()).hexdigest()
                content_hashes.append((output_path, content_hash))
                continue

                
            elif item_type == "fix-dependency":
                # Fix-dependency task generation
                item_id = source_item.get("id", "unknown")
                dependency_ref = source_item.get("dependency_ref", "unknown")
                
                # Generate deterministic patch file
                content = f"""# Generated by ShieldCraft Engine
# Fix missing dependency: {dependency_ref}
# Lineage ID: {source_item.get('lineage_id', 'unknown')}
# Source Pointer: {source_item.get('source_pointer', 'unknown')}
# Source Node Type: {source_item.get('source_node_type', 'unknown')}

def fix_dependency():
    \"\"\"
    Placeholder for fixing missing dependency: {dependency_ref}
    \"\"\"
    pass
"""
                
                outputs.append({
                    "path": f"fixes/{item_id}.py",
                    "content": content
                })
            elif item_type == "resolve-invariant":
                # Resolve-invariant task generation
                template_path = self.template_dir / "fix_invariant.j2"
                
                if template_path.exists():
                    template_content = template_path.read_text()
                    from jinja2 import Template
                    template = Template(template_content)
                    
                    context = {
                        "lineage_id": source_item.get("lineage_id", "unknown"),
                        "spec_ptr": source_item.get("source_pointer", "unknown"),
                        "invariant_type": source_item.get("invariant_type", "unknown"),
                        "constraint": source_item.get("invariant_constraint", "unknown")
                    }
                    
                    rendered = template.render(context)
                    
                    item_id = source_item.get("id", "unknown")
                    outputs.append({
                        "path": f"fixes/{item_id}.py",
                        "content": rendered
                    })
            elif item_type == "resolve-cycle":
                # Resolve-cycle task generation
                template_path = self.template_dir / "resolve_cycle.j2"
                
                if template_path.exists():
                    template_content = template_path.read_text()
                    from jinja2 import Template
                    template = Template(template_content)
                    
                    cycle_items = source_item.get("cycle_items", [])
                    context = {
                        "lineage_id": source_item.get("lineage_id", "unknown"),
                        "cycle_items": cycle_items,
                        "cycle_length": len(cycle_items)
                    }
                    
                    rendered = template.render(context)
                    
                    item_id = source_item.get("id", "unknown")
                    outputs.append({
                        "path": f"cycles/{item_id}.py",
                        "content": rendered
                    })
            elif item_type == "integration":
                # Integration task generation
                template_path = self.template_dir / "integration.j2"
                
                if template_path.exists():
                    template_content = template_path.read_text()
                    from jinja2 import Template
                    template = Template(template_content)
                    
                    context = {
                        "lineage_id": source_item.get("lineage_id", "unknown"),
                        "spec_ptr": source_item.get("ptr", "unknown"),
                        "item_id": source_item.get("id", "unknown")
                    }
                    
                    rendered = template.render(context)
                    
                    item_id = source_item.get("id", "unknown")
                    outputs.append({
                        "path": f"integration/{item_id}.py",
                        "content": rendered
                    })
            else:
                # Regular generation
                template_path = self.template_dir / (entry["template_name"] + ".txt")
                template = template_path.read_text()

                context = {
                    "task_id": entry["id"],
                    "ptr": entry["source"]["ptr"],
                    "summary": entry["source"]["text"]
                }

                # render expects template content, not name
                rendered = self.engine.render(template, context)
                
                # Inject lineage header
                rendered = self._inject_lineage_header(rendered, source_item)
                outputs.append({
                    "path": entry["output_path"],
                    "content": rendered
                })
        
        # Auto-generate __init__.py for module directories
        module_dirs = set()
        for output in outputs:
            path = output["path"]
            if "modules/" in path:
                # Extract module directory
                parts = path.split("/")
                modules_idx = parts.index("modules") if "modules" in parts else -1
                if modules_idx >= 0 and modules_idx + 1 < len(parts):
                    # Build path up to modules directory
                    module_dir = "/".join(parts[:modules_idx + 2])
                    module_dirs.add(module_dir)
        
        # Generate __init__.py for each module directory
        for module_dir in sorted(module_dirs):
            init_path = f"{module_dir}/__init__.py"
            
            # Check if __init__.py already exists in outputs
            if not any(out["path"] == init_path for out in outputs):
                # Generate deterministic __init__.py
                init_content = f"""# Generated by ShieldCraft Engine
# Lineage ID: module-init
# Source Pointer: {module_dir}
# Auto-generated module initializer

pass
"""
                outputs.append({
                    "path": init_path,
                    "content": init_content
                })
        
        # Compute content hashes for all outputs
        from shieldcraft.util.canonical_digest import digest_text
        import hashlib
        
        for output in outputs:
            content = output.get("content", "")
            content_hash = digest_text(content)
            content_hashes.append((output["path"], content_hash))
        
        # Compute bundle hash
        sorted_hashes = sorted(content_hashes, key=lambda x: x[0])
        bundle_hash_input = "".join(f"{path}:{hash}" for path, hash in sorted_hashes)
        codegen_bundle_hash = hashlib.sha256(bundle_hash_input.encode()).hexdigest()
        
        # Handle dry_run mode
        if dry_run:
            preview_entries = []
            for output in outputs:
                path = output["path"]
                content = output.get("content", "")
                # Find content hash for this path
                content_hash = next((h for p, h in content_hashes if p == path), "")
                # Preview first 120 chars
                preview = content[:120] if len(content) > 120 else content
                preview_entries.append({
                    "path": path,
                    "content_hash": content_hash,
                    "preview": preview
                })
            return preview_entries
        
        # Return full result
        return {
            "outputs": outputs,
            "codegen_bundle_hash": codegen_bundle_hash,
            "file_count": len(outputs)
        }
    
    def generate(self, ast, items):
        """
        Generate code from AST and checklist items.
        Walk AST and items, load templates, render code.
        Returns structured code bundle (no IO).
        """
        code_bundle = []
        
        for item in items:
            # Only process items that require code
            if not item.get("requires_code", False):
                continue
            
            # Determine template based on category
            category = item.get("category", "default")
            template_name = self._get_template_name(category, item)
            
            # Load template
            try:
                template_content = self.engine.load_template(template_name)
            except FileNotFoundError:
                # Fallback to default
                template_content = self.engine.load_template("default.j2")
            
            # Prepare context with traceability metadata
            metadata = {
                "source_item_id": item.get("id", "unknown"),
                "source_pointer": item.get("source_pointer", item.get("ptr", "/")),
                "source_section": item.get("source_section", "unknown")
            }
            
            context = {
                "item_id": item.get("id", "unknown"),
                "ptr": item.get("ptr", "/"),
                "text": item.get("text", ""),
                "category": category,
                "metadata": metadata,
                "source_pointer": metadata["source_pointer"],
                "source_section": metadata["source_section"]
            }
            
            # Render
            rendered = self.engine.render(template_content, context)
            
            code_bundle.append({
                "item_id": item.get("id"),
                "category": category,
                "template": template_name,
                "code": rendered,
                "metadata": metadata
            })
        
        # Compute codegen bundle hash (deterministic)
        content_hashes = []
        for entry in code_bundle:
            import hashlib
            code_hash = hashlib.sha256(entry["code"].encode()).hexdigest()
            content_hashes.append((entry["item_id"], code_hash))
        
        sorted_hashes = sorted(content_hashes, key=lambda x: x[0])
        import hashlib
        bundle_hash_input = "".join(f"{path}:{hash}" for path, hash in sorted_hashes)
        codegen_bundle_hash = hashlib.sha256(bundle_hash_input.encode()).hexdigest()
        
        return {
            "items": code_bundle,
            "count": len(code_bundle),
            "codegen_bundle_hash": codegen_bundle_hash
        }
    
    def _get_template_name(self, category, item=None):
        """Deterministic template matching rules with bootstrap support."""
        # Bootstrap routing
        if category == "bootstrap":
            item_type = item.get("type", "default") if item else "default"
            bootstrap_template = f"bootstrap/{item_type}.j2"
            # Check if bootstrap template exists
            bootstrap_path = self.template_dir / bootstrap_template
            if bootstrap_path.exists():
                return bootstrap_template
            # Fallback to default
            return "default.j2"
        
        # Map category to template file
        template_map = {
            "api": "api_handler.j2",
            "rule": "rule.j2",
            "model": "model.j2"
        }
        
        return template_map.get(category, "default.j2")
