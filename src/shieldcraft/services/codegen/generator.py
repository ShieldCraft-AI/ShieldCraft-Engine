import pathlib
from .template_engine import TemplateEngine
from .file_plan import FilePlan


class CodeGenerator:
    def __init__(self, template_dir="src/shieldcraft/services/codegen/templates"):
        self.template_dir = pathlib.Path(template_dir)
        self.engine = TemplateEngine(template_dir)
        self.plan_builder = FilePlan()

    def _inject_lineage_header(self, content, item):
        """Inject lineage provenance header into generated file."""
        import hashlib as _hashlib
        lineage_id = item.get("lineage_id")
        # If no explicit lineage id, derive a deterministic one from ptr or id
        if not lineage_id:
            ptr = item.get("ptr") or item.get("id") or "unknown"
            lineage_id = _hashlib.sha256(str(ptr).encode()).hexdigest()
        spec_ptr = item.get("source_pointer", item.get("ptr", "unknown"))
        source_node_type = item.get("source_node_type", "unknown")

        from shieldcraft.version import VERSION as SE_VERSION
        header = f"""# Generated by ShieldCraft Engine
    # Engine Version: {SE_VERSION}
    # Lineage ID: {lineage_id}
    # Source Pointer: {spec_ptr}
    # Source Node Type: {source_node_type}
    #
    """
        # Include placeholder provenance if template used default placeholders
        try:
            if (item.get("meta") or {}).get("template_placeholders"):
                header += "# Placeholder defaults used in template: true\n"
        except Exception:
            pass
        # Ensure header is the first content (strip leading newlines)
        return header + content.lstrip("\n")

    def run(self, checklist, dry_run=False):
        import hashlib
        # Preserve caller input shape to support legacy behavior
        input_was_list = isinstance(checklist, list)
        file_plan = self.plan_builder.build_file_plan(checklist)
        outputs = []
        content_hashes = []

        for entry in file_plan:
            # Check for module type
            source_item = entry.get("source", {})
            item_type = source_item.get("type", "")
            item_category = source_item.get("category", "")

            # If this source item contains model modules (spec-level model declaration),
            # generate a module output for each module entry.
            value = source_item.get("value")
            if isinstance(value, dict) and "modules" in value and isinstance(value["modules"], list):
                modules = value["modules"]
                for module in modules:
                    template_path = self.template_dir / "module.j2"
                    if not template_path.exists():
                        template_path = self.template_dir / (entry["template_name"] + ".txt")

                    template = template_path.read_text()
                    # Detect Jinja placeholders that use default(...) â€” record placeholder provenance on item meta
                    try:
                        if "| default(" in template:
                            if "meta" not in source_item:
                                source_item["meta"] = {}
                            source_item["meta"]["template_placeholders"] = True
                    except Exception:
                        pass

                    context = {
                        "name": module.get("name", "UnknownModule"),
                        "dependencies": module.get("dependencies", []),
                        "invariants": module.get("invariants", []),
                        "checklist_id": entry["id"]
                    }

                    rendered = self.engine.render(template, context)
                    # Inject lineage header using the parent source item (spec/model)
                    rendered = self._inject_lineage_header(rendered, source_item)

                    module_name = module.get("name", "unknown")
                    module_path = f"src/generated/modules/{module_name}.py"

                    outputs.append({
                        "path": module_path,
                        "content": rendered
                    })

                    content_hash = hashlib.sha256(rendered.encode()).hexdigest()
                    content_hashes.append((module_path, content_hash))
                continue

            # Bootstrap module generation
            if item_category == "bootstrap":
                # Use bootstrap module template
                template_path = self.template_dir / "bootstrap" / "module_bootstrap.j2"

                if template_path.exists():
                    # Read template and render with Jinja2
                    template_content = template_path.read_text()

                    context = {
                        "name": source_item.get("name", source_item.get("ptr", "Unknown").split("/")[-1]),
                        "checklist_id": entry["id"]
                    }

                    # Use Jinja2 directly for proper rendering
                    from jinja2 import Template
                    jinja_template = Template(template_content)
                    rendered = jinja_template.render(context)

                    # Bootstrap output path
                    module_name = context["name"]
                    bootstrap_path = f".selfhost_outputs/bootstrap/{module_name}.py"

                    outputs.append({
                        "path": bootstrap_path,
                        "content": rendered
                    })
                    continue

            if item_type == "module":
                # Module generation
                template_path = self.template_dir / "module.j2"
                if not template_path.exists():
                    # Fallback to basic template
                    template_path = self.template_dir / (entry["template_name"] + ".txt")

                template = template_path.read_text()

                context = {
                    "name": source_item.get("name", "UnknownModule"),
                    "dependencies": source_item.get("dependencies", []),
                    "invariants": source_item.get("invariants", []),
                    "checklist_id": entry["id"]
                }

                rendered = self.engine.render(template, context)

                # Inject lineage header
                rendered = self._inject_lineage_header(rendered, source_item)

                # Module output path
                module_name = source_item.get("name", "unknown")
                module_path = f"src/generated/modules/{module_name}.py"

                outputs.append({
                    "path": module_path,
                    "content": rendered
                })

                # Compute content hash for dry-run and bundle hash
                content_hash = hashlib.sha256(rendered.encode()).hexdigest()
                content_hashes.append((module_path, content_hash))
                continue

            # Route derived task types to templates. For legacy list-based callers
            # prefer the simple text templates (basic_python.txt) to preserve
            # backward-compatible output formatting.
            template_map = {
                "module": "module.j2",
                "fix-dependency": "fix_invariant.j2",
                "resolve-cycle": "resolve_cycle.j2",
                "integration": "integration.j2"
            }

            if input_was_list:
                template_name = entry.get("template_name", "basic_python") + ".txt"
            else:
                template_name = template_map.get(item_type, "module.j2")
            template_path = self.template_dir / template_name

            if template_path.exists():
                template_content = template_path.read_text()

                if input_was_list:
                    # Simplified rendering for legacy list input: provide task-level
                    # context so basic text templates contain task id/ptr/summary.
                    context = {
                        "task_id": entry.get("id"),
                        "ptr": entry.get("source", {}).get("ptr", ""),
                        "summary": entry.get("source", {}).get("text", "")
                    }
                    rendered = self.engine.render(template_content, context)
                    rendered = self._inject_lineage_header(rendered, entry.get("source", {}))
                    outputs.append({"path": entry["output_path"], "content": rendered})
                    content_hash = hashlib.sha256(rendered.encode()).hexdigest()
                    content_hashes.append((entry["output_path"], content_hash))
                    continue

                # Build context for template
                context = {
                    "lineage_id": source_item.get("lineage_id", "unknown"),
                    "spec_ptr": source_item.get("source_pointer", source_item.get("ptr", "unknown")),
                    "name": source_item.get("name", "unknown"),
                    "invariant_id": source_item.get("invariant_id", ""),
                    "constraint": source_item.get("invariant_constraint", ""),
                    "cycle_items": source_item.get("cycle_items", []),
                    "component_name": source_item.get("name", "component")
                }

                from jinja2 import Template
                jinja_template = Template(template_content)
                rendered = jinja_template.render(context)
                # Inject lineage header for provenance
                rendered = self._inject_lineage_header(rendered, source_item)

                # Route to output path based on type
                output_map = {
                    "module": f"src/generated/modules/{context['name']}.py",
                    "fix-dependency": f"src/generated/fixes/{source_item.get('id', 'fix')}.py",
                    "resolve-cycle": f"src/generated/cycles/{source_item.get('id', 'cycle')}.py",
                    "integration": f"src/generated/integration/{source_item.get('id', 'test')}.py"
                }

                output_path = output_map.get(item_type, f"src/generated/unknown/{source_item.get('id', 'item')}.py")

                outputs.append({
                    "path": output_path,
                    "content": rendered
                })

                content_hash = hashlib.sha256(rendered.encode()).hexdigest()
                content_hashes.append((output_path, content_hash))
                continue

            elif item_type == "fix-dependency":
                # Fix-dependency task generation
                item_id = source_item.get("id", "unknown")
                dependency_ref = source_item.get("dependency_ref", "unknown")

                # Generate deterministic patch file
                content = f"""# Generated by ShieldCraft Engine
# Fix missing dependency: {dependency_ref}
# Lineage ID: {source_item.get('lineage_id', 'unknown')}
# Source Pointer: {source_item.get('source_pointer', 'unknown')}
# Source Node Type: {source_item.get('source_node_type', 'unknown')}

def fix_dependency():
    \"\"\"
    Placeholder for fixing missing dependency: {dependency_ref}
    \"\"\"
    pass
"""

                outputs.append({
                    "path": f"fixes/{item_id}.py",
                    "content": content
                })
            elif item_type == "resolve-invariant":
                # Resolve-invariant task generation
                template_path = self.template_dir / "fix_invariant.j2"

                if template_path.exists():
                    template_content = template_path.read_text()
                    from jinja2 import Template
                    template = Template(template_content)

                    context = {
                        "lineage_id": source_item.get("lineage_id", "unknown"),
                        "spec_ptr": source_item.get("source_pointer", "unknown"),
                        "invariant_type": source_item.get("invariant_type", "unknown"),
                        "constraint": source_item.get("invariant_constraint", "unknown")
                    }

                    rendered = template.render(context)

                    item_id = source_item.get("id", "unknown")
                    outputs.append({
                        "path": f"fixes/{item_id}.py",
                        "content": rendered
                    })
            elif item_type == "resolve-cycle":
                # Resolve-cycle task generation
                template_path = self.template_dir / "resolve_cycle.j2"

                if template_path.exists():
                    template_content = template_path.read_text()
                    from jinja2 import Template
                    template = Template(template_content)

                    cycle_items = source_item.get("cycle_items", [])
                    context = {
                        "lineage_id": source_item.get("lineage_id", "unknown"),
                        "cycle_items": cycle_items,
                        "cycle_length": len(cycle_items)
                    }

                    rendered = template.render(context)

                    item_id = source_item.get("id", "unknown")
                    outputs.append({
                        "path": f"cycles/{item_id}.py",
                        "content": rendered
                    })
            elif item_type == "integration":
                # Integration task generation
                template_path = self.template_dir / "integration.j2"

                if template_path.exists():
                    template_content = template_path.read_text()
                    from jinja2 import Template
                    template = Template(template_content)

                    context = {
                        "lineage_id": source_item.get("lineage_id", "unknown"),
                        "spec_ptr": source_item.get("ptr", "unknown"),
                        "item_id": source_item.get("id", "unknown")
                    }

                    rendered = template.render(context)

                    item_id = source_item.get("id", "unknown")
                    outputs.append({
                        "path": f"integration/{item_id}.py",
                        "content": rendered
                    })
            else:
                # Regular generation
                template_path = self.template_dir / (entry["template_name"] + ".txt")
                template = template_path.read_text()

                context = {
                    "task_id": entry["id"],
                    "ptr": entry["source"]["ptr"],
                    "summary": entry["source"]["text"]
                }

                # render expects template content, not name
                rendered = self.engine.render(template, context)

                # Inject lineage header
                rendered = self._inject_lineage_header(rendered, source_item)
                outputs.append({
                    "path": entry["output_path"],
                    "content": rendered
                })

        # Auto-generate __init__.py for module directories
        module_dirs = set()
        for output in outputs:
            path = output["path"]
            if "modules/" in path:
                # Extract module directory
                parts = path.split("/")
                modules_idx = parts.index("modules") if "modules" in parts else -1
                if modules_idx >= 0 and modules_idx + 1 < len(parts):
                    # Build path up to modules directory
                    module_dir = "/".join(parts[:modules_idx + 2])
                    module_dirs.add(module_dir)

        # Generate __init__.py for each module directory
        for module_dir in sorted(module_dirs):
            init_path = f"{module_dir}/__init__.py"

            # Check if __init__.py already exists in outputs
            if not any(out["path"] == init_path for out in outputs):
                # Generate deterministic __init__.py
                import hashlib as _hashlib
                lineage_hash = _hashlib.sha256(module_dir.encode()).hexdigest()
                init_content = f"""# Generated by ShieldCraft Engine
# Lineage ID: {lineage_hash}
# Source Pointer: {module_dir}
# Auto-generated module initializer
# INTENTIONAL: Empty __init__.py - valid Python package marker
"""
                outputs.append({
                    "path": init_path,
                    "content": init_content
                })

        # Compute content hashes for all outputs
        from shieldcraft.util.canonical_digest import digest_text
        import hashlib

        for output in outputs:
            content = output.get("content", "")
            content_hash = digest_text(content)
            content_hashes.append((output["path"], content_hash))

        # Compute bundle hash
        sorted_hashes = sorted(content_hashes, key=lambda x: x[0])
        bundle_hash_input = "".join(f"{path}:{hash}" for path, hash in sorted_hashes)
        codegen_bundle_hash = hashlib.sha256(bundle_hash_input.encode()).hexdigest()

        # Handle dry_run mode
        if dry_run:
            preview_entries = []
            for output in outputs:
                path = output["path"]
                content = output.get("content", "")
                # Find content hash for this path
                content_hash = next((h for p, h in content_hashes if p == path), "")
                # Preview first 120 chars
                preview = content[:120] if len(content) > 120 else content
                preview_entries.append({
                    "path": path,
                    "content_hash": content_hash,
                    "preview": preview
                })
            # Legacy: when caller passed a simple list, return preview list
            if input_was_list:
                return preview_entries
            # New shape: return dict with metadata and outputs
            return {
                "outputs": outputs,
                "preview": preview_entries,
                "codegen_bundle_hash": codegen_bundle_hash,
                "file_count": len(outputs)}

        # Return full result (legacy behavior: always return list of outputs)
        return outputs

    def generate(self, ast, items):
        """
        Generate code from AST and checklist items.
        Walk AST and items, load templates, render code.
        Returns structured code bundle (no IO).
        """
        code_bundle = []

        for item in items:
            # Only process items that require code
            if not item.get("requires_code", False):
                continue

            # Determine template based on category
            category = item.get("category", "default")
            template_name = self._get_template_name(category, item)

            # Load template
            try:
                template_content = self.engine.load_template(template_name)
            except FileNotFoundError:
                # Fallback to default
                template_content = self.engine.load_template("default.j2")

            # Prepare context with traceability metadata
            metadata = {
                "source_item_id": item.get("id", "unknown"),
                "source_pointer": item.get("source_pointer", item.get("ptr", "/")),
                "source_section": item.get("source_section", "unknown")
            }

            context = {
                "item_id": item.get("id", "unknown"),
                "ptr": item.get("ptr", "/"),
                "text": item.get("text", ""),
                "category": category,
                "metadata": metadata,
                "source_pointer": metadata["source_pointer"],
                "source_section": metadata["source_section"]
            }

            # Render
            rendered = self.engine.render(template_content, context)

            code_bundle.append({
                "item_id": item.get("id"),
                "category": category,
                "template": template_name,
                "code": rendered,
                "metadata": metadata
            })

        # Compute codegen bundle hash (deterministic)
        content_hashes = []
        for entry in code_bundle:
            import hashlib
            code_hash = hashlib.sha256(entry["code"].encode()).hexdigest()
            content_hashes.append((entry["item_id"], code_hash))

        sorted_hashes = sorted(content_hashes, key=lambda x: x[0])
        import hashlib
        bundle_hash_input = "".join(f"{path}:{hash}" for path, hash in sorted_hashes)
        codegen_bundle_hash = hashlib.sha256(bundle_hash_input.encode()).hexdigest()

        return {
            "items": code_bundle,
            "count": len(code_bundle),
            "codegen_bundle_hash": codegen_bundle_hash
        }

    def _get_template_name(self, category, item=None):
        """Deterministic template matching rules with bootstrap support."""
        # Bootstrap routing
        if category == "bootstrap":
            item_type = item.get("type", "default") if item else "default"
            bootstrap_template = f"bootstrap/{item_type}.j2"
            # Check if bootstrap template exists
            bootstrap_path = self.template_dir / bootstrap_template
            if bootstrap_path.exists():
                return bootstrap_template
            # Fallback to default
            return "default.j2"

        # Map category to template file
        template_map = {
            "api": "api_handler.j2",
            "rule": "rule.j2",
            "model": "model.j2"
        }

        return template_map.get(category, "default.j2")
