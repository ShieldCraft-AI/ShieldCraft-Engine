{
  "bootstrap_items": 0,
  "checklist_execution_plan": {
    "cycle_groups": {},
    "missing_artifacts": [],
    "ordered_item_count": 15,
    "priority_violations": []
  },
  "codegen_bundle_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
  "fingerprint": "b833bf6ae63f33c6",
  "manifest_version": "v1",
  "outputs": [
    "repo_snapshot.json"
  ],
  "provenance": {
    "engine_version": "0.1.0",
    "snapshot_hash": "44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a",
    "spec_fingerprint": "b833bf6ae63f33c6"
  },
  "spec_fingerprint": "b833bf6ae63f33c6",
  "spec_metadata": {
    "normalized": true,
    "product_id": "unknown",
    "source_format": "text",
    "source_material": "THE LITMUS ENGINE\n\nDeterministic Governance for Safe First Decisions\n\nInternal tagline:\nA senior reviewer that knows when not to speak.\n\n0. What This Is\n\nTHE LITMUS ENGINE is a zero-trust governance layer for code.\n\nIt is a deterministic engine that resolves structural information asymmetry before any change is committed.\n\nLitmus exists to answer one question, decisively and safely:\n\nWhat would be irresponsible to touch right now?\n\nThis repository contains an operational system that:\n\n\nConsumes a repository snapshot\n\nProduces signed, auditable decision artifacts\n\nExplicitly defines where action is safe, unsafe, or impossible\n\nRefuses to speak when evidence is insufficient\n\nIf this repository exists without artifacts, it is incorrect.\n\nIncorrectness should be obvious without reading documentation.\n\n1. Brutal Framing\nWho This Is For\n\nEngineers inheriting unfamiliar or legacy systems\n\nTechnical leads deciding where to apply pressure safely\n\nArchitects accountable for migration, refactor, or audit risk\n\nDue diligence reviewers assessing change exposure\n\nTeams optimizing for fewer irreversible mistakes\n\nWho This Is Not For\n\nCode style enforcement\n\nAutomated refactoring\n\nExhaustive issue discovery\n\nMetrics that reward activity\n\nTools that maximize findings\n\nNon-Negotiable Design Constraint\n\nLitmus enforces a deliberate architectural trade-off:\n\nPrecision over Exhaustivity.\n\nIt will sacrifice discovering N low-severity issues to achieve full confidence at the boundary of the Safe-to-Change Surface.\n\nIf your goal is speed through confidence, this is the wrong tool.\nIf your goal is speed through restraint, this is the tool.\n\n2. Why This Exists\n\nMost repository tools are optimized for exhaustive signal production.\n\nThey:\n\nDetect presence, not consequence\n\nConflate detection with importance\n\nSound confident where evidence is thin\n\nEncourage premature action\n\nLitmus is optimized for actionable signal suppression.\n\nFalse confidence causes more damage than missing information.\nThe most dangerous failure mode in unfamiliar systems is the wrong first change.\n\nLitmus exists to prevent that class of failure.\n\n3. Execution Boundary (Unavoidable)\n\nLitmus is not a library and not a suggestion engine.\n\nIt has a fixed execution boundary:\n\nRuns as a deterministic analysis step\n\nConsumes a repository snapshot\n\nProduces signed decision artifacts\n\nAdvisory by default\n\nBlocking only when explicitly configured\n\nBlocking is a governance choice.\nLitmus is strict only when strictness is justified.\n\n4. Proof of Seriousness (Structural, Not Aspirational)\n\nThe repository structure must make the following unavoidable.\n\n4.1 Governance Signature\n\nEvery run emits a canonical decision artifact and a SHA-256 hash.\n\nThis hash is the Litmus Governance Signature.\n\nIt binds guidance to the exact input state and makes the output auditable, reproducible, and non-repudiable.\n\nIdentical input must always produce the same signature.\n\nMissing or unstable signatures indicate failure.\n\n4.2 Refusal as a First-Class Artifact\n\nThe repository must contain a documented refusal case.\n\nExample condition:\n\nCritical migration logic exists without tests or contracts.\nNo safe change surface can be established.\n\nRefusal is a successful outcome.\n\nThe system must demonstrate more rigor around refusal than around detection.\n\n4.3 Misleading Signal Restraint\n\nThe repository must contain a case where:\n\nA na\u00efve tool would escalate\n\nLitmus explicitly does not\n\nThe restraint is evidence-anchored\n\nRestraint is treated as a capability, not an omission.\n\n5. Foundational Invariants\n5.1 Absolute Determinism\n\nNo timestamps\n\nNo randomness\n\nNo environment leakage\n\nCanonical traversal and ordering\n\nVerifiable governance signature\n\nDeterminism failures must look like broken builds, not TODOs.\n\n5.2 Observable Evidence Only\n\nPermitted signals:\n\nStructure and boundaries\n\nConfiguration and contracts\n\nTests and coverage\n\nDependency topology\n\nVersioning and migration artifacts\n\nForbidden signals:\n\nNaming interpretation\n\nComment sentiment\n\nHeuristic psychology\n\nRuntime speculation\n\n5.3 Enforced Restraint\n\nSeverity-gated output\n\nExplicit verbosity ceilings\n\n\u201cNothing notable\u201d is valid\n\nSilence is a required outcome\n\nSilence requires confidence, not laziness.\n\n6. Trust Contract\n\nEvery major conclusion must include at least one of:\n\nWhy the conclusion is reliable\n\nWhy it is explicitly bounded\n\nWhy a less disciplined tool would mislead here\n\nTrust is earned by exposing limits.\n\n7. Intent Modeling (Architectural Posture)\n\nLitmus does not infer motivation.\nIt classifies architectural posture.\n\n7.1 Permitted Signals\n\nBoundary enforcement\n\nGovernance strictness\n\nMigration and deprecation handling\n\nInvestment asymmetry\n\n7.2 Evolutionary Archetypes\n\nEach posture includes evidence, confidence, and expiration logic.\n\nExamples:\n\nThe Pressure Cooker\nPosture: High-Velocity Instability\n\nThe Museum\nPosture: Stagnant Entropy Hazard\n\nThe Construction Site\nPosture: Guarded Evolution\n\nThe Patchwork\nPosture: Uneven Maturity\n\n7.3 Calibration Effect\n\nPosture classification applies a calibration multiplier to severity gating.\n\nIdentical findings carry different weight depending on posture.\n\nPosture is the first risk filter.\n\n8. Safe-to-Change Surface (Primary Artifact)\n8.1 Conceptual Model\n\nThe Safe-to-Change Surface is a risk-aversion boundary model, not a score.\n\nIt is derived from two parameters:\n\nThe file set \n\ud835\udc39\nF\n\nThe maximum tolerable risk threshold \n\ud835\udf0f\n\u03c4\n\n8.2 Formal Definition\n\nThe Safe-to-Change Surface \n\ud835\udc39\n\ud835\udc46\n\u2282\n\ud835\udc39\nF\nS\n\t\u200b\n\n\u2282F is defined by the condition:\n\n\ud835\udc35\n(\n\ud835\udc53\n)\n\u2264\n\ud835\udf0f\nB(f)\u2264\u03c4\n\nNo-Touch Zones are the complement set \n\ud835\udc39\n\u2216\n\ud835\udc39\n\ud835\udc46\nF\u2216F\nS\n\t\u200b\n\n.\n\n8.3 Required Properties\n\nExplicit safe zones\n\nExplicit no-touch zones\n\nEvidence references\n\nExpiration logic\n\n8.4 Mandatory First Move\n\nEvery run must provide one of:\n\nA concrete safe first action\n\nAn explicit statement that no safe move exists\n\nAbsence of a safe surface is itself a finding.\n\n9. Strategic De-Prioritization Artifact\n\nLitmus must identify Negative ROI Optimization candidates.\n\nDefinition:\n\nIssues where the Cost of Change exceeds the Cost of Failure by an order of magnitude, based on observable invariants such as age, stability, and dependency isolation.\n\nThis artifact explicitly answers:\n\nWhat not to fix\n\nWhy it is benign\n\nWhen it would stop being benign\n\nThis is enforced, not optional.\n\n10. Uncertainty and Refusal\n10.1 Visible Uncertainty\n\nUncertainty must be:\n\nLocalized\n\nCalm\n\nExplicitly bounded\n\nNo absolutes where evidence is partial.\n\n10.2 Mandatory Refusal Conditions\n\nLitmus must refuse when:\n\nCritical paths lack tests or contracts\n\nBlast radius cannot be bounded\n\nConfiguration is contradictory\n\nRefusal is success.\n\n11. Multi-Language Boundary Control\n\nOne primary language per run\n\nSecondary languages analyzed structurally only\n\nNo semantic inference across boundaries\n\nThis prevents false authority.\n\n12. Output Contract\n12.1 Executive Summary\n\nConstraints:\n\nOne page maximum\n\nZero subjective adjectives\n\nEvery statement traceable to evidence\n\nMust answer:\n\nIs it safe to act\n\nWhere\n\nWhere not\n\nWhat is unknowable\n\n12.2 Decision Artifacts\n\nSafe-to-Change Surface\n\nNo-Touch Zones\n\nMisleading Signals\n\nFirst Recommended Action or Explicit Refusal\n\n12.3 Evidence Appendix\n\nEvidence references only\n\nNo commentary\n\nNo speculation\n\n13. Tone and Voice\n\nCalm\n\nDirect\n\nSenior\n\nNo hype\n\nNo AI voice\n\nReads like a VP-level technical memo.\n\n14. Deterministic Silence Requirement\n\nSeverity-gated verbosity\n\nExplicit \u201cNothing notable\u201d verdicts allowed\n\nBrevity enforced structurally\n\n15. Definition of Senior Judgment\n\nIn this system, senior judgment is defined as:\n\nCorrectly modeling second-order consequences and prioritizing structural integrity over feature velocity.\n\nLitmus supports this judgment.\nIt does not replace it.\n\n16. Final Litmus Test\n\nA senior engineer reading the output should think:\n\n\u201cThis is exactly what I would have said.\nAnd I trust it because it knows when not to speak.\u201d\n\nIf this fails, the implementation is incorrect.\n\n17. Why This Exists as a Narrow System\n\nIt prevents damage instead of producing noise\n\nIt treats restraint as a capability\n\nIt makes refusal executable\n\nIt is deterministic, auditable, and calm\n\nIt optimizes for safe first decisions\n\nThe narrowness is not a limitation.\nIt is the point.",
    "spec_format": "canonical_json_v1",
    "spec_version": "0.0"
  }
}